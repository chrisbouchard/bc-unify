fmod TRAVERSE is
    protecting APPLY .
    protecting META-LEVEL .

    *** A sort to represent some sort of value, or possibly the absence of a
    *** value.
    ***
    sort Value .

    vars M : Module .
    vars OP : Context .
    vars F : Qid .
    vars X : Value .
    vars T : Term .
    vars TL : TermList .
    vars C : Constant .
    vars V : Variable .
    vars RESULT : ResultPair? .

    *** The absence of a value.
    ***
    op nothing : -> Value [ctor] .

    *** A polymorphic constructor for a value. Any sort can be a value. We hide
    *** the value inside this constructor so we can define equations -- we're
    *** really only interested in its meta-representation anyway.
    ***
    op value : Universal -> Value [ctor poly(1)] .

    *** Apply an operation to each node in the term tree in a bottom-up way.
    ***
    op traverse : Module Context Value -> Value .
    ceq traverse(M, OP, X) =
        downTerm('value[getTerm(metaReduce(M, $traverse(M, OP, T)))], nothing)
        if 'value[T] := upTerm(X) .
    eq traverse(M, OP, X) = nothing [owise] .

    op $traverse : Module Context Term ~> Term .
    eq $traverse(M, OP, F[TL]) = doOp(M, OP, F[$traverse-list(M, OP, TL)]) .
    eq $traverse(M, OP, C) = doOp(M, OP, C) .
    eq $traverse(M, OP, V) = V .

    op $traverse-list : Module Context TermList ~> Term .
    eq $traverse-list(M, OP, (T, TL)) =
        $traverse(M, OP, T), $traverse-list(M, OP, TL) .
    eq $traverse-list(M, OP, empty) = empty .

    op doOp : Module Context Term ~> Term .
    ceq doOp(M, OP, T) = getTerm(RESULT)
        if RESULT := metaReduce(M, OP[T]) /\ RESULT :: ResultPair
        /\ not (getType(RESULT) :: Kind) .
    eq doOp(M, OP, T) = T [owise] .
endfm

