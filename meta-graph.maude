load graph

fmod META-GRAPH{E :: EDGE} is
    pr EXT-BOOL .
    pr GRAPH{E} .
    pr META-LEVEL .

    vars A B : E$Edge .
    vars G H : Graph{E} .
    vars N M O : E$Node .
    vars Q : Qid .
    vars T : Term .
    vars U : Type .
    vars MOD : Module .
    vars OP : Qid .

    op meta-path : Module Qid E$Node E$Node Graph{E} -> Path .

    op meta-path(_,_,_,_,_,_) : Module Qid E$Node E$Node Graph{E} Qid ~> Graph{E} .
    eq meta-path(MOD, OP, N, N, G, Q) = emptygraph .
    eq meta-path(MOD, OP, N, M, G, Q) = meta-nePath(MOD, OP, N, M, G, Q) [owise] .

    op meta-nePath(_,_,_,_,_,_) : Module Qid E$Node E$Node NeGraph{E} Qid ~> NeGraph{E} .
    ceq meta-nePath(MOD, OP, N, M, A || G, Q) = A if N M := nodes(A) .
    ceq meta-nePath(MOD, OP, N, M, A || G, Q) = A || H
        if N O := nodes(A) /\ H := meta-path(MOD, OP, O, M, G, Q)
        /\ H =/= nopath /\ ((Q == 'any and check-path-any(MOD, OP, H))
                            or (Q == 'each and check-path-each(MOD, OP, H))) .
    ceq meta-nePath(MOD, OP, N, M, A || G, Q) = A || H
        if O M := nodes(A) /\ H := meta-path(MOD, OP, N, O, G, Q)
        /\ H =/= nopath /\ ((Q == 'any and check-path-any(MOD, OP, H))
                            or (Q == 'each and check-path-each(MOD, OP, H))) .
    eq meta-nePath(MOD, OP, N, M, G, Q) = nopath [owise] .

    op check-path-any(_,_,_) : Module Qid Graph{E} -> Bool .
    eq check-path-any(MOD, OP, A || G) =
        getTerm(metaReduce(MOD, OP[upTerm(A)])) == 'true.Bool
        or-else check-path-any(MOD, OP, G) .
    eq check-path-any(MOD, OP, G) = false [owise] .

    op check-path-each(_,_,_) : Module Qid Graph{E} -> Bool .
    eq check-path-each(MOD, OP, A || G) =
        getTerm(metaReduce(MOD, OP[upTerm(A)])) == 'true.Bool
        and-also check-path-each(MOD, OP, G) .
    eq check-path-each(MOD, OP, G) = true [owise] .
endfm

