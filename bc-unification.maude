load graph
load inference
load unificand-set

fmod BC-SIGNATURE is
    protecting META-LEVEL .
    protecting UNIFICAND-SET .

    sorts BCSignature .

    *** The signature is just given as a sequence of Qids. Maybe this should
    *** become something better, but pattern-matching works for now.
    op ______ : Qid Qid Qid Constant Type Type -> BCSignature [ctor] .

    op bc-infer : UnificandSet BCSignature Nat -> UnificationPair? .
endfm

fmod BC-UNIFICATION is
    protecting BC-SIGNATURE .
    protecting INFERENCE .
    protecting UNIFICAND-SET .

    vars N SKIP : Nat .
    vars SIG : BCSignature .
    vars PROB : UnificationProblem .
    vars EQ : UnificandSet .

    *** This is the entry-point for BC unification.
    op bc-unify : UnificationProblem BCSignature Nat Nat -> UnificationPair? .
    eq bc-unify(PROB, SIG, N, SKIP) =
        downTerm(inferenceRules(upModule('BC-INFERENCE, false),
                                upTerm(bc-infer(problemToSet(PROB), SIG, N)),
                                upTerm((noUnifier).UnificationPair?), SKIP),
                 (noUnifier).UnificationPair?) .
endfm

mod BC-INFERENCE is
    protecting BC-SIGNATURE .
    protecting UNIFICAND-SET .

    vars N : Nat .
    vars EQ : UnificandSet .

    vars T T1 T2 : Term .
    vars U V W X Y Z : Variable .
    vars U' U'' V' X' X'' : Variable .
    vars BC H CONS : Qid .
    vars NIL : Constant .
    vars ELT LIST : Type .

    *** This helper function is defined over our more usable unificand
    *** sets.
    op bc-infer : UnificandSet BCSignature Nat -> UnificationPair? .

    rl [rep-elim] :
        bc-infer(U =? T & U =? T & EQ, BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? T & EQ, BC H CONS NIL ELT LIST, N)
        [metadata "prec 1 det"] .

    rl [triv-elim] :
        bc-infer(U =? U & EQ, BC H CONS NIL ELT LIST, N)
        => bc-infer(EQ, BC H CONS NIL ELT LIST, N)
        [metadata "prec 1 det"] .

    crl [var-elim] :
        bc-infer(U =? V & EQ, BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? V & replace(U, V, EQ), BC H CONS NIL ELT LIST, N)
        if occurs(U, EQ)
        [metadata "prec 2 det"] .

    rl [cancel-cons] :
        bc-infer(U =? CONS[V, W] & U =? CONS[X, Y] & EQ,
                 BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? CONS[V, W] & X =? V & Y =? W & EQ,
                    BC H CONS NIL ELT LIST, N)
        [metadata "prec 3 det"] .

    rl [nil-soln-1] :
        bc-infer(U =? BC[V, W] & U =? NIL & EQ, BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? NIL & V =? NIL & EQ, BC H CONS NIL ELT LIST, N)
        [metadata "prec 4 det"] .

    rl [nil-soln-2] :
        bc-infer(U =? BC[V, W] & V =? NIL & EQ, BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? NIL & V =? NIL & EQ, BC H CONS NIL ELT LIST, N)
        [metadata "prec 4 det"] .

    crl [nil-soln-3] :
        bc-infer(U =? BC[V, W] & EQ, BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? NIL & V =? NIL & EQ, BC H CONS NIL ELT LIST, N)
        if true
        [metadata "prec 4 det"] .

    rl [semi-cancel-bc] :
        bc-infer(U =? BC[V, W] & U =? BC[X, W] & EQ, BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? BC[V, W] & X =? V & EQ, BC H CONS NIL ELT LIST, N)
        [metadata "prec 5 det"] .

    crl [push-below] :
        bc-infer(U =? BC[V, W] & U =? BC[X, Y] & EQ,
                 BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? CONS[U', U''] & V =? CONS[V', Z] & X =? CONS[X', Z] &
                    U'' =? BC[Z, U'] & U' =? H[V', W] & U' =? H[X', Y] & EQ,
                    BC H CONS NIL ELT LIST, N + 5)
        if false
        /\ U' := newVar*(N,     ELT) /\ U'' := newVar*(N + 1, LIST)
        /\ V' := newVar*(N + 2, ELT) /\ Z   := newVar*(N + 3, LIST)
        /\ X' := newVar*(N + 4, ELT)
        [metadata "prec 6 det"] .

    crl [splitting] :
        bc-infer(U =? CONS[V, W] & U =? BC[X, Y] & EQ,
                 BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? CONS[V, W] & X =? CONS[X', X''] & V =? H[X', Y] &
                    W =? BC[X'', V] & EQ,
                    BC H CONS NIL ELT LIST, N + 2)
        if X' := newVar*(N, ELT) /\ X'' := newVar*(N + 1, LIST)
        [metadata "prec 7 det"] .

    rl [size-failure] :
        bc-infer(U =? CONS[V, W] & U =? NIL & EQ, BC H CONS NIL ELT LIST, N)
        => noUnifier
        [metadata "prec 0 det"] .

    crl [cycle-failure] :
        bc-infer(EQ, BC H CONS NIL ELT LIST, N)
        => noUnifier
        if false
        [metadata "prec 0 det"] .
endm

view Variable from TRIV to META-TERM is
    sort Elt to Variable .
endv

fmod BC-EDGE is
    protecting META-TERM .
    protecting SIMPLE-SET{Variable}
        * (sort SimpleSet{Variable} to BCSimpleSet,
           sort NeSimpleSet{Variable} to NeBCSimpleSet) .

    sorts BCEdge .

    op bcE : Variable Variable -> BCEdge [ctor] .
    op consE : Variable Variable -> BCEdge [ctor] .

    vars U V W : Variable .
    vars E : BCEdge .

    op from : BCEdge Variable -> Bool .
    eq from(bcE(U, V), W) = U == W or V == W .
    eq from(consE(U, V), W) = U == W .

    op to : BCEdge Variable -> Bool .
    eq to(bcE(U, V), W) = U == W or V == W .
    eq to(consE(U, V), W) = V == W .

    op nodes : BCEdge -> NeBCSimpleSet .
    eq nodes(bcE(U, V)) = s(U, V) .
    eq nodes(consE(U, V)) = s(U, V) .

    op _>bc_in_ : Variable Variable BCEdge -> Bool .
    eq U >bc V in bcE(U, V) = true .
    eq U >bc V in E = false [owise] .
endfm

view BCEdge from EDGE to BC-EDGE is
    sort Node to Variable .
    sort Edge to BCEdge .
    sort NodeSet to BCSimpleSet .
    sort NeNodeSet to NeBCSimpleSet .
endv

fmod BC-GRAPH is
    protecting EXT-BOOL .
    protecting META-GRAPH{BCEdge}
        * (sort Graph{BCEdge} to BCGraph,
           sort NeGraph{BCEdge} to NeBCGraph,
           sort Path{BCEdge} to BCPath,
           sort NePath{BCEdge} to NeBCPath,
           sort Path?{BCEdge} to BCPath?,
           sort NePath?{BCEdge} to NeBCPath?) .

    vars U V W : Variable .
    vars E : BCEdge .
    vars P : BCPath .

    op _>bc*_in_ : Variable Variable BCPath -> Bool .
    eq U >bc* V in P = U == V or-else U >bc+ V in P .

    op _>bc+_in_ : Variable Variable BCPath -> Bool .
    ceq U >bc+ V in E P = U >bc W in E and-then (W == V or-else W >bc+ V in P)
        if s(U, W) := nodes(E) .
endfm

