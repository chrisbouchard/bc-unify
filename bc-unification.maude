load graph
load inference
load unificand-set

fth BC is
    --- Sorts for element and list are assumed to be completely disjoint.
    sorts Elt List .

    op cons : Elt List -> List .
    op nil : -> List .
    op bc : List Elt -> List .
    op h : Elt Elt -> Elt .

    vars X Z : Elt .
    vars Y : List .

    --- The axioms of BC. They form a canonical rewrite system.
    eq bc(nil, Z) = nil [nonexec] .
    eq bc(cons(X, Y), Z) = cons(h(X, Z), bc(Y, h(X, Z)) [nonexec] .
endfth

fmod BC-SIGNATURE is
    protecting META-LEVEL .
    protecting UNIFICAND-SET .

    sorts BCSignature .

    *** The signature is just given as a sequence of Qids. Maybe this should
    *** become something better, but pattern-matching works for now.
    op ______ : Qid Qid Qid Constant Type Type -> BCSignature [ctor] .

    op bc-infer : UnificandSet BCSignature Nat -> UnificationPair? .
endfm

fmod BC-UNIFICATION is
    protecting BC-SIGNATURE .
    protecting INFERENCE .
    protecting UNIFICAND-SET .

    vars N SKIP : Nat .
    vars SIG : BCSignature .
    vars PROB : UnificationProblem .
    vars EQ : UnificandSet .

    *** This is the entry-point for BC unification.
    op bc-unify : UnificationProblem BCSignature Nat Nat -> UnificationPair? .
    eq bc-unify(PROB, SIG, N, SKIP) =
        downTerm(inferenceRules(upModule('BC-INFERENCE, false),
                                upTerm(bc-infer(problemToSet(PROB), SIG, N)),
                                upTerm((noUnifier).UnificationPair?), SKIP),
                 (noUnifier).UnificationPair?) .
endfm

view Variable from TRIV to META-TERM is
    sort Elt to Variable .
endv

fmod BC-EDGE is
    protecting META-TERM .
    protecting SIMPLE-SET{Variable}
        * (sort SimpleSet{Variable} to BCSimpleSet,
           sort NeSimpleSet{Variable} to NeBCSimpleSet) .

    sorts BCEdge .

    op bcE : Variable Variable -> BCEdge [ctor] .
    op consE : Variable Variable -> BCEdge [ctor] .

    vars U V W : Variable .
    vars E : BCEdge .

    op from : BCEdge Variable -> Bool .
    eq from(bcE(U, V), W) = U == W or V == W .
    eq from(consE(U, V), W) = U == W .

    op to : BCEdge Variable -> Bool .
    eq to(bcE(U, V), W) = U == W or V == W .
    eq to(consE(U, V), W) = V == W .

    op nodes : BCEdge -> NeBCSimpleSet .
    eq nodes(bcE(U, V)) = s(U, V) .
    eq nodes(consE(U, V)) = s(U, V) .

    op _>bc_in_ : Variable Variable BCEdge -> Bool .
    eq U >bc V in bcE(U, V) = true .
    eq U >bc V in E = false [owise] .

    op isBc : BCEdge -> Bool .
    eq isBc(bcE(U, V)) = true .
    eq isBc(E) = false [owise] .

    op isCons : BCEdge -> Bool .
    eq isCons(consE(U, V)) = true .
    eq isCons(E) = false [owise] .
endfm

view BCEdge from EDGE to BC-EDGE is
    sort Node to Variable .
    sort Edge to BCEdge .
    sort NodeSet to BCSimpleSet .
    sort NeNodeSet to NeBCSimpleSet .
endv

fmod BC-GRAPH is
    protecting EXT-BOOL .
    protecting META-GRAPH{BCEdge}
        * (sort Graph{BCEdge} to BCGraph,
           sort NeGraph{BCEdge} to NeBCGraph,
           sort Path{BCEdge} to BCPath,
           sort NePath{BCEdge} to NeBCPath,
           sort Path?{BCEdge} to BCPath?,
           sort NePath?{BCEdge} to NeBCPath?) .

    vars E : BCEdge .
    vars G : BCGraph .
    vars P : BCPath .
    vars NeP : NeBCPath .
    vars S : BCSimpleSet .
    vars U V : Variable .

    op isBcPath : BCPath -> Bool .
    ceq isBcPath(E P) = $isBcPath(U, E P)
        if s(U, V) := nodes(E) /\ U >bc V in E .
    eq isBcPath(P) = false [owise] .

    op $isBcPath : Variable BCPath -> Bool .
    ceq $isBcPath(U, E NeP) = U >bc V in E and-then $isBcPath(V, NeP)
        if s(U, V) := nodes(E) .
    ceq $isBcPath(U, E) = U >bc V in E
        if s(U, V) := nodes(E) .
    eq $isBcPath(U, emptypath) = false .

    op isLPath : BCPath -> Bool .
    eq isLPath(E P) = isCons(E) or-else (isBc(E) and-then isLPath(P)) .
    eq isLPath(emptypath) = false .

    op hasBcCycle : BCGraph -> Bool .
    eq hasBcCycle(G) = hasCycle(G, ['BC-GRAPH], 'isBcPath[[]]) .

    op hasLCycle : BCGraph -> Bool .
    eq hasLCycle(G) = hasCycle(G, ['BC-GRAPH], 'isLPath[[]]) .
endfm

mod BC-INFERENCE is
    protecting BC-GRAPH .
    protecting BC-SIGNATURE .
    protecting UNIFICAND-SET .

    vars N : Nat .
    vars EQ : UnificandSet .
    vars SIG : BCSignature .

    vars T T1 T2 : Term .
    vars U V W X Y Z : Variable .
    vars U' U'' V' X' X'' : Variable .
    vars BC H CONS : Qid .
    vars NIL : Constant .
    vars ELT LIST : Type .
    vars S : QidSet .

    *** This helper function is defined over our more usable unificand
    *** sets.
    op bc-infer : StUnificandSet BCSignature Nat -> UnificationPair? .

    rl [rep-elim] :
        bc-infer(U =? T & U =? T & EQ, BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? T & EQ, BC H CONS NIL ELT LIST, N)
        [metadata "prec 1 det"] .

    rl [triv-elim] :
        bc-infer(U =? U & EQ, BC H CONS NIL ELT LIST, N)
        => bc-infer(EQ, BC H CONS NIL ELT LIST, N)
        [metadata "prec 1 det"] .

    crl [var-elim] :
        bc-infer(U =? V & EQ, BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? V & replace(U, V, EQ), BC H CONS NIL ELT LIST, N)
        if occurs(U, EQ)
        [metadata "prec 2 det"] .

    rl [cancel-cons] :
        bc-infer(U =? CONS[V, W] & U =? CONS[X, Y] & EQ,
                 BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? CONS[V, W] & X =? V & Y =? W & EQ,
                    BC H CONS NIL ELT LIST, N)
        [metadata "prec 3 det"] .

    rl [nil-soln-1] :
        bc-infer(U =? BC[V, W] & U =? NIL & EQ, BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? NIL & V =? NIL & EQ, BC H CONS NIL ELT LIST, N)
        [metadata "prec 4 det"] .

    rl [nil-soln-2] :
        bc-infer(U =? BC[V, W] & V =? NIL & EQ, BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? NIL & V =? NIL & EQ, BC H CONS NIL ELT LIST, N)
        [metadata "prec 4 det"] .

    crl [nil-soln-3] :
        bc-infer(U =? BC[V, W] & EQ, BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? NIL & V =? NIL & EQ, BC H CONS NIL ELT LIST, N)
        if hasBcCycle(buildGraph(EQ, BC H CONS NIL ELT LIST))
        [metadata "prec 4 det"] .

    rl [semi-cancel-bc] :
        bc-infer(U =? BC[V, W] & U =? BC[X, W] & EQ, BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? BC[V, W] & X =? V & EQ, BC H CONS NIL ELT LIST, N)
        [metadata "prec 5 det"] .

    crl [push-below] :
        bc-infer(U =? BC[V, W] & U =? BC[X, Y] & EQ,
                 BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? CONS[U', U''] & V =? CONS[V', Z] & X =? CONS[X', Z] &
                    U'' =? BC[Z, U'] & U' =? H[V', W] & U' =? H[X', Y] & EQ,
                    BC H CONS NIL ELT LIST, N + 5)
        if U in nonnil(U =? BC[V, W] & U =? BC[X, Y] & EQ,
                       BC H CONS NIL ELT LIST)
        /\ U' := newVar*(N,     ELT) /\ U'' := newVar*(N + 1, LIST)
        /\ V' := newVar*(N + 2, ELT) /\ Z   := newVar*(N + 3, LIST)
        /\ X' := newVar*(N + 4, ELT)
        [metadata "prec 6 det"] .

    crl [splitting] :
        bc-infer(U =? CONS[V, W] & U =? BC[X, Y] & EQ,
                 BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? CONS[V, W] & X =? CONS[X', X''] & V =? H[X', Y] &
                    W =? BC[X'', V] & EQ,
                    BC H CONS NIL ELT LIST, N + 2)
        if X' := newVar*(N, ELT) /\ X'' := newVar*(N + 1, LIST)
        [metadata "prec 7 det"] .

    rl [size-failure] :
        bc-infer(U =? CONS[V, W] & U =? NIL & EQ, BC H CONS NIL ELT LIST, N)
        => noUnifier
        [metadata "prec 0 det"] .

    crl [cycle-failure] :
        bc-infer(EQ, BC H CONS NIL ELT LIST, N)
        => noUnifier
        if hasLCycle(buildGraph(EQ, BC H CONS NIL ELT LIST))
        [metadata "prec 0 det"] .


    *** Convert a set of unificands into a dependency graph.
    op buildGraph : UnificandSet BCSignature -> BCGraph .
    eq buildGraph(U =? CONS[V, W] & EQ, BC H CONS NIL ELT LIST) =
        bcE(U, W) || buildGraph(EQ, BC H CONS NIL ELT LIST) .
    eq buildGraph(U =? BC[V, W] & EQ, BC H CONS NIL ELT LIST) =
        bcE(U, V) || buildGraph(EQ, BC H CONS NIL ELT LIST) .
    eq buildGraph(U =? T & EQ, BC H CONS NIL ELT LIST) =
        buildGraph(EQ, BC H CONS NIL ELT LIST) [owise] .


    op nonnil : UnificandSet BCSignature -> QidSet .
    eq nonnil(EQ, SIG) = $nonnil(EQ, none, SIG) .

    op $nonnil : UnificandSet QidSet BCSignature -> QidSet .
    eq $nonnil(U =? CONS[V, W] & EQ, S, BC H CONS NIL ELT LIST) =
        $nonnil(EQ, (U ; S), BC H CONS NIL ELT LIST) .
    ceq $nonnil(U =? BC[V, W] & EQ, S, BC H CONS NIL ELT LIST) =
        $nonnil(EQ, (U ; V ; W ; S), BC H CONS NIL ELT LIST)
        if (U in S) or (V in S) or (W in S) .
    ceq $nonnil(U =? V & EQ, S, BC H CONS NIL ELT LIST) =
        $nonnil(EQ, (U ; V ; S), BC H CONS NIL ELT LIST)
        if (U in S) or (V in S) .
    eq $nonnil(EQ, S, SIG) = S [owise] .
endm

