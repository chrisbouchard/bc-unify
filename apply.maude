fmod CAP is
    protecting META-TERM .

    sorts Cap NeCapList NeGTermList .
    subsorts Context < Cap NeCTermList < NeCapList .
    subsorts NeTermList NeCapList < NeGTermList < GTermList .

    op _[_] : Qid NeCapList -> Cap .

    op _,_ : NeCapList TermList -> NeCapList [ctor ditto] .
    op _,_ : TermList NeCapList -> NeCapList [ctor ditto] .
    op _,_ : NeCapList NeCapList -> NeCapList [ctor ditto] .

    vars GTL : GTermList .
    vars NeGTL : NeGTermList .
    vars T : Term .
    vars C : Cap .
    vars F : Qid .
    vars A : Constant .
    vars V : Variable .
    vars N : Nat .

    op countHoles : GTermList -> Nat .
    eq countHoles([]) = 1 .
    eq countHoles(V) = 0 .
    eq countHoles(A) = 0 .
    eq countHoles(F[GTL]) = countHoles(GTL) .
    eq countHoles((T, NeGTL)) = countHoles(T) + countHoles(NeGTL) .
    eq countHoles((C, NeGTL)) = countHoles(C) + countHoles(NeGTL) .
    eq countHoles(empty) = 0 .

    op listSize : GTermList -> Nat .
    eq listSize((T, GTL)) = 1 + listSize(GTL) .
    eq listSize((C, GTL)) = 1 + listSize(GTL) .
    eq listSize(empty) = 0 .
endfm

fmod APPLY is
    protecting CAP .
    protecting META-TERM .
    protecting NAT .

    vars C : Cap .
    vars CL : NeCapList .
    vars GTL GTL' GTL'' GTL''' : GTermList .
    vars NeGTL : NeGTermList .
    vars T : Term .
    vars F : Qid .
    vars SUB SUB' : Substitution .
    vars A : Constant .
    vars V : Variable .
    vars N : Nat .

    op _[_] : Cap GTermList -> [Cap] .
    op _[_] : Context Cap -> Cap .
    op _[_] : Context Term -> Term .
    op _[_] : Context Context -> Context .

    eq [][T] = T .
    eq [][C] = C .
    ceq F[CL][GTL] = F[applyContext(CL, GTL)]
        if countHoles(CL) = listSize(GTL) .

    op applyContext : GTermList GTermList -> [GTermList] .
    op applyContext : NeCTermList Cap -> NeCapList .
    op applyContext : NeCTermList Term -> TermList .
    op applyContext : NeCTermList Context -> NeCTermList .

    eq applyContext((T, GTL), GTL') = T, applyContext(GTL, GTL') .
    ceq applyContext((C, GTL), GTL') = C[GTL''], applyContext(GTL, GTL''')
        if not (C :: Term) /\ N := countHoles(C)
        /\ GTL'' := take(GTL', N) /\ GTL''' := skip(GTL', N) .
    eq applyContext(empty, empty) = empty .

    op take : GTermList Nat -> GTermList .
    eq take((T, GTL), s N) = T, take(GTL, N) .
    eq take(GTL, 0) = empty .

    op skip : GTermList Nat -> GTermList .
    eq skip((T, GTL), s N) = skip(GTL, N) .
    eq skip(GTL, 0) = GTL .


    op _[_] : Substitution Cap -> Cap .
    op _[_] : Substitution Term -> Term .
    op _[_] : Substitution Context -> Context .
    op _[_] : Substitution Substitution -> Substitution .

    eq SUB[A] = A .
    eq SUB[[]] = [] .

    eq (V <- T ; SUB)[V] = T .
    eq SUB[V] = V [owise] .

    eq SUB[F[GTL]] = F[applySubst(SUB, GTL)] .

    eq SUB[V <- T ; SUB'] = V <- SUB[T] ; SUB[SUB'] .
    eq SUB[none] = none .

    op applySubst : Substitution GTermList -> GTermList .
    eq applySubst(SUB, (T, GTL)) = SUB[T], applySubst(SUB, GTL) .
    eq applySubst(SUB, (C, GTL)) = SUB[C], applySubst(SUB, GTL) .
    eq applySubst(SUB, empty) = empty .
endfm

