\documentclass[11pt,twoside,titlepage]{article}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{epsfig}
\usepackage{amssymb, amsmath, amsthm, amsxtra}
\usepackage{mathtools}
\usepackage{graphics, graphicx}
\usepackage{fancyhdr, fancyvrb}
\usepackage{proof}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{color}
\usepackage{authblk}
\usepackage{url}
\usepackage[sectionbib,sort,numbers]{natbib}
\usepackage[shortlabels]{enumitem}
\usepackage{multicol}
\usepackage{listings}
\usepackage{fancybox}
\usepackage[nottoc,section]{tocbibind}
\usepackage[bookmarks]{hyperref}
\usepackage{bookmark}

\renewcommand{\tocbibname}{\refname}

\newcommand{\ueq}{=_{}^?}
\newcommand{\compcirc}{\, {\scriptstyle{\circ}} \,}

\newcommand{\A}{\mathcal{A}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\T}{\mathcal{T}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\K}{\mathcal{K}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\p}{\mathcal{P}}
\newcommand{\h}{\mathcal{H}}

\newcommand{\Nat}{\mathbb{N}}

\newcommand{\BC}{\mathcal{BC}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\EQ}{\mathcal{EQ}}
\newcommand{\Pos}{\mathcal{P}\!os}
\newcommand{\FPos}{\mathcal{FP\!}os}
\newcommand{\Var}{\mathcal{V}\!ar}

\newcommand{\Elt}{\mathrm{Elt}}
\newcommand{\List}{\mathrm{List}}

\newcommand{\Bc}{\mathit{bc}}
\newcommand{\Hh}{\mathit{h}}
\newcommand{\Cons}{\mathit{cons}}
\newcommand{\Nil}{\mathit{nil}}

\newcommand{\Nonnil}{\mathbf{nonnil}}

\newcommand{\Fail}{\mathrm{FAIL}}

\DeclareMathOperator{\Gr}{\mathit{Gr}}
\DeclareMathOperator{\Mgu}{\mathit{mgu}}

\newcommand{\Reduced}[1]{#1 \negmedspace\downarrow}
\newcommand{\Sub}[2]{{\left.{#1}\right|_{#2}^{}}}

\newcommand{\TitleListing}[1]{\texorpdfstring{\lstinline|#1|}{#1}}

\bibliographystyle{plainnat}

% Default settings for listings
\lstset{
    basicstyle=\ttfamily,
    moredelim=**[is][\itshape]{@/}{/@},
    moredelim=**[is][\bfseries]{@@}{@@},
    showstringspaces=false,
}

\lstdefinestyle{smalllisting}{
    basicstyle=\small\ttfamily,
}

% Definition of Maude for lstlistings
\lstdefinelanguage{Maude}{
    alsoletter={\:},
    morecomment=[l]{---},
    morecomment=[l]{***},
    morecomment=[n]{***(}{)},
    morestring=[b]{"},
    keywords={load, pr, protecting, sort, sorts, subsort, subsorts, including,
              class, msg, msgs, endfm, fmod, is, mod, endm, omod, endom, view,
              endv, from, to, TODO\:},
    keywords=[2]{eq,  mb, ceq, if, rl, crl, else, then, fi},
    keywords=[3]{ctor, assoc, comm, gather, id\:, label, metadata, owise, prec,
                 special, ditto, format},
    keywords=[4]{op, ops, var, vars},
    keywords=[5]{=, =>, ->, ~>, ::},
}

\setlength{\textheight}{8.5in}
\setlength{\columnsep}{2.0pc}
\setlength{\textwidth}{6.75in}
\setlength{\topmargin}{0.25in}
\setlength{\headheight}{0.0in}
\setlength{\headsep}{0.0in}
\setlength{\parskip}{0.05in}
\setlength{\oddsidemargin}{-.15in}
\setlength{\evensidemargin}{-.15in}
\setlength{\parindent}{1pc}

\pagestyle{plain}

\title{Implementing Unification modulo Chaining}
\author{Christopher Bouchard}
\date{\today}

\pagenumbering{roman}

\begin{document}

\begin{titlepage}
    \pdfbookmark{Implementing Unification modulo Chaining}{Title Page}
    {\vspace*{-1in}\hspace*{-.5in}
    \parbox{7.25in}{
    \setlength{\baselineskip}{13pt}
    \makebox{\ } \hfill {\footnotesize College of Computing and Information} \\
    \makebox{\ } \hfill {\footnotesize Computer Science Department} \\
    \makebox{\ } \\
    \\
    }
    \vspace{-.95in}}

    \epsfxsize=3.15in
    \epsfclipon
    \hspace{-0.5in}{\raggedright{
    \epsffile{logo_A2_pms124_269.eps}
    }}

    \vspace*{2in}

    \begin{center}
        \textbf{\huge Implementing Unification modulo Chaining} \\[+15pt]
        \textbf{(Master's Project)}
        \par
    \end{center}

    \vspace{2in}

    \begin{center}
    \textbf{\large Christopher Bouchard}\\

    \par\end{center}{\large \par}

    \begin{center}
    \textbf{\large \vspace{0.5in}
    Advisor: Paliath Narendran }\textbf{ }
    \par\end{center}
\end{titlepage}

\thispagestyle{empty}
\cleardoublepage

\begin{center}
    \textbf{Abstract}
\end{center}
\begin{quotation}
Equational unification is an important research area with many applications,
such as cryptographic protocol analysis, automated theorem proving, and
automated reasoning. In ``Unification modulo
Chaining''~\cite{anantharaman2012unification}, an algorithm is presented for
solving unification problems modulo a theory of chaining. The algorithm is
modular in the sense that it does not depend on the interpretation of the
elements in the lists, but is instead parameterized by a suitable element
unification algorithm. We present an implementation of this algorithm in the
Maude programming language.

\medskip{}
\textit{Keywords:} Cipher block chaining, Equational unification, Maude, Protocol
analysis, Term rewriting.
\end{quotation}

\clearpage

\begin{center}
    \textbf{Acknowledgements}
\end{center}
\begin{quotation}
I would first like to thank my advisor, Paliath Narendran. It is due to his
guidance and insight that I chose not only this line of research, but to enter
the Ph.D.\ program in the first place.
I would like to thank my coauthors on ``Unification modulo Chaining,'' Siva
Anantharaman, Dr.\ Narendran, and Micha\"{e}l Rusinowitch, for their patience
and expertise while I learned the ropes of academic writing.

I would like to thank my academic older brothers, Andrew Marshall and Serdar
Erbatur, for taking the time to mentor and encourage a first year grad student.
I now \emph{ful{}ly} understand how busy they must have been.
I would also like to thank my friends and teammates, Kim Gero, Peter Hibbs, and
Andrew ``Basil'' Matusiewicz, for making this department a place that I look
forward to going to. This journey would have been much more arduous without
their camaraderie.

I would like to thank my parents for their continued support.
And I would like to thank my girlfriend, Mary Ferro, for more than I can say.
Beyond just listening to my babbling about algorithms and ``the paper,'' her
love and belief in me when I had lost my confidence have kept me going. Thank
you.

This work was supported in part by NSF grant CNS~09-05286.
\end{quotation}

\clearpage
\tableofcontents

\clearpage
\pagenumbering{arabic}

\section{Introduction}\label{section:intro}

Equational unification is an important research area with many applications in
cryptographic protocol analysis and automated reasoning. One such application
in protocol analysis is the study of a technique called \emph{cipher block
chaining}, invented in 1978 at IBM~\cite{ehrsam1978message} and currently used
in the SSL and TLS cryptographic protocols~\cite{rfc5246}. In cipher block
chaining, one encrypts blocks of a message by masking the current block with
the previous encrypted block, then applying the encryption function to the
result. This forces an attacker to decrypt all previous blocks before
decrypting a later block, preventing him or her from attacking individual
blocks in parallel.

Formally, if a message's plaintext contains blocks $[M_1, \dotsc, M_n]$, then
the ciphertext will contain blocks $[C_1, \dotsc, C_n]$ such that:
\begin{align*}
    C_1 &= e_k(M_1 \oplus IV) &
    C_{i+1} &= e_k(M_i \oplus C_i)
\end{align*}
where $e_k$ represents block-level encryption with a key $k$, $\oplus$
represents XOR, and $IV$ represents an \emph{initialization vector} --- a
random initial input.

In ``Unification modulo Chaining,'' the authors present an algorithm for
solving unification problems modulo a general theory of \emph{chaining}, then
show how this can be used to solve problems modulo cipher block chaining in
particular~\cite{anantharaman2012unification}. The notion of chaining
corresponds to performing a \emph{right fold} of a list, but keeping the
partial results.  In ML, such a function might look like:
\begin{lstlisting}[language=ML, style=smalllisting]
    fun chain f z [] = []
      | chain f z (x::ls) = f (z,x) :: chain f (f (z,x)) ls;
\end{lstlisting}
For example, we can combine \lstinline|chain| with addition, in which case we
get partial sums:
\begin{lstlisting}[language=ML, style=smalllisting]
    - chain (op +) 0 [1, 2, 3, 4];
    > val it = [1, 3, 6, 10] : int list
\end{lstlisting}
Note that the function \lstinline|chain| is a higher-order function, taking as
its first argument a function \lstinline|f|. Since we are interested in
first-order unification, we will generally consider chaining with a fixed
function.

One of the motivations behind this implementation is a tool called The
Maude-NPA\footnote{Maude-NPA: \url{http://maude.cs.uiuc.edu/tools/Maude-NPA/}},
developed at the Naval Research Lab. Maude-NPA uses term-rewriting and
algebraic properties to analyze cryptographic protocols at a symbolic
level~\cite{escobar2009maude}.  The Maude-NPA project incorporates
implementations of unification algorithms for a range of cryptographic
operations and protocols. The fact that Maude-NPA is written in
Maude\footnote{The Maude System: \url{http://maude.cs.uiuc.edu/}}, combined
with Maude's excellent reflective and rewriting capabilities, made the language
a prime candidate for our implementation.

\section{Notation and Preliminaries}\label{section:notation}

We consider a rewrite system over a ranked signature, denoted $\Sigma$, and a
possibly infinite set of variables, denoted $\X$. We assume the reader is
familiar with the usual notions and concepts in term rewriting systems and
equational unification~\cite{Term, BaaderSnyd-01}. An \emph{equation} is an
ordered pair of terms $(s, \, t)$, usually written as $s \approx t$. Here
$s$~is the \emph{le\vspace{-0.2pt}ft-hand side} and $t$~is the \emph{right-hand
side} of the equation. A \emph{theory} is a set of equations, in which case the
equations are also called \emph{axioms}. A \emph{rewrite rule} is an equation
$s \approx t$ where $\Var(s) \supseteq \Var(t)$, usually written as~$s \to t$.
A \emph{term rewriting system} (or simply \emph{rewrite system}) is a set of
rewrite rules.

\subsection{Unification}\label{subsection:unification}

Unification is the problem of solving equations with respect to a particular
theory. Given a theory $E$, an instance of the \emph{unification problem modulo
$E$} is a set of equations $\p = \{s_1 \ueq t_1, \dotsc, s_n \ueq t_n\}$. (The
symbol $\ueq$ rather than $\approx$ is customary to indicate that these are
equations to be solved rather than axioms.) A solution is a substitution
$\sigma$ such that $\sigma(s_1) \approx^{}_E \sigma(t_1) \, \wedge \, \dotsb \,
\wedge \, \sigma(s_n) \approx^{}_E \sigma(t_n)$. Such a solution is also called
an \emph{$E$-unifier} of $\p$, or simply a \emph{unifier} if the theory is
clear from the context.

A set of equations $\p = \{x_1 \ueq t_1, \dotsc x_n \ueq t_n\}$ is said to be
in \emph{dag-solved form} if all of the following conditions
hold~\cite{jouannaud1991solving}:
\begin{enumerate}[(i)]
    \item Each $x_i$ is a variable.
    \item Each $x_i$ is unique, i.e., $x_i = x_j$ iff $i = j$.
    \item If $i < j$, then $x_i$ does not occur in $t_j$.
\end{enumerate}
It is this last condition that gives dag-solved form its name, because the
equations can be thought to form a directed acyclic graph. A set of equations
in dag solved form has the following unifier:
\[\sigma = (x_n \mapsto t_n) \compcirc \dotsb \compcirc (x_1 \mapsto t_1)\]
where $\compcirc$ is function composition.

\subsection{Standard Form}\label{subsection:standard-form}

The algorithm assumes that the unification problem is given in \emph{standard
form}, in which each equation has one of the following forms:
\begin{enumerate}[(i)]
    \item $U \ueq V$, where $U$ and $V$ are variables
    \item $U \ueq f(V_1, \dotsc, V_n)$, where $U$ and $V_1$ through $V_n$ are
        variables and $f$ is a function symbol with the appropriate arity
\end{enumerate}
Any unification problem $\p$ can be transformed into a unification problem
$\p'$ in standard form such that unifiability is preserved and any unifier of
$\p'$ is a unifier of $\p$. Doing so need only introduce a number of new variables
linear in the size of the input problem.

\subsection{Many-Sorted Signature}\label{subsection:signature}

In this paper, we consider unification modulo a many-sorted
algebra~\cite{walther1988many, kirchner1988order}, with disjoint sorts $\Elt$
and $\List$ representing elements and lists, respectively.\footnote{In
``Unification modulo Chaining,'' the names $\tau_e$ and $\tau_l$ are used for
$\Elt$ and $\List$, respectively.} Each function symbol in $\Sigma$ has an
associated type signature, and terms that are not well-typed are considered
syntactically invalid. The function symbols and their type signatures are given
below:
\begin{align*}
    \Bc \colon &\List \times \Elt \to \List &
    \Cons \colon &\Elt \times \List \to \List \\
    \Hh \colon &\Elt \times \Elt \to \Elt &
    \Nil \colon &\List
\end{align*}
Additionally, the set of variables $\X$ is partitioned into two disjoint subsets,
$\X_E$ and $\X_L$, containing the variables of sorts $\Elt$ and $\List$, respectively.
We will use lower case names (e.g., $u$, $v$, $w$) for variables in $\X_E$, and
uppercase names (e.g., $U$, $V$, $W$) for variables in $\X_L$. In general, variable
names will use letters later in the alphabet.

We extend the typing of terms to equations in standard form. If $U \ueq t$ is
an equation in standard form, then $U \ueq t$ is well-typed iff $U$ and $t$
have the same sort. We call this the sort of the equation. For example, the
equation $U \ueq \Cons(v, W)$ has sort $\List$ --- we say $U \ueq \Cons(v, W)$
is a \emph{list equation}. Similarly, $u \ueq h(x, y)$ has sort $\Elt$ and is
an \emph{element equation}.

\section{The Theory of Chaining (\texorpdfstring{$\BC$}{BC})}
\label{section:theory}

The theory of chaining, $\BC$ (for ``block chaining''), is given by the
following two axioms:
\begin{align*}
    \Bc(\Nil, z) &\approx \Nil \\
    \Bc(\Cons(x, Y), z) &\approx \Cons(\Hh(x, z), \Bc(Y, \Hh(x, z)))
\end{align*}
The intended meaning is that $\Bc$ represents a chaining function, which chains
a function symbol $\Hh$ across the list in its first argument. For now the
symbol $\Hh$ is uninterpreted. The second argument of $\Bc$ contains the
previous result. The function symbols $\Cons$ and $\Nil$ are the standard list
constructors.

When oriented from left to right into a rewrite system, $\BC$ is convergent.
In ``Unification modulo Chaining,'' it was shown that unification modulo $\BC$
is finitary, but not unitary.

\subsection{The Element Theory (\texorpdfstring{$\HH$}{H})}
\label{subsection:element-theory}

Since chaining is a higher-order operation, we consider a fixed function $\Hh$.
We assume there is a theory $\HH$ that interprets $\Hh$, which we call the
\emph{element theory}. This theory should be non-subterm-collapsing and
$\Hh$ should be semi-cancellative. A function symbol is semi-cancellative iff
it has the property that:
\[ \Hh(t_1, s_1) \approx_\HH^{} \Hh(t_2, s_2) \quad \Rightarrow \quad
t_1 \approx_\HH^{} t_2 \; \Leftrightarrow \; s_1 \approx_\HH^{} s_2 \]
for all terms $t_1, s_1, t_2, s_2$. Additionally, unification modulo $\HH$
should be finitary.

Two element theories were considered in ``Unification modulo Chaining'': one in
which $\Hh$ is left uninterpreted, and another in which $\Hh$ is interpreted by
$\Hh(x, y) = e_k(x \oplus y)$, where $\oplus$ is XOR and $e_k$ is an
uninterpreted function symbol representing encryption with a fixed key $k$.
Note that this latter interpretation, combined with $\BC$, is exactly the
definition of cipher block chaining.

In the remaining sections, when we talk about unification modulo chaining,
we will be referring to unification modulo the combined theory $\BC \cup \HH$
for some $\HH$.

\section{Algorithm for Unification modulo Chaining}\label{section:algorithm}

The algorithm in ``Unification modulo Chaining'' is divided into two phases.
The first phase is given by a system of inference rules that transform the
set of list equations into dag-solved form by breaking \emph{peaks} (variables
equated to two different terms). The second phase uses a provided
element unification algorithm to find a unifier for the element equations.
Finally, the unifiers are combined and the result is returned.

\subsection{Inference Rules}\label{subsection:inference}

For our purposes, an \emph{inference rule} is a rule for transforming a set of
equations, possibly with a condition limiting its application. For example, one
inference rule from the algorithm looks like:
\[\infer
    {\EQ ~ \cup ~ \{ U \ueq cons(v, W), \; x \ueq v, \; Y \ueq W \}}
    {\EQ ~ \uplus ~ \{ U \ueq cons(v, W), \; U \ueq cons(x, Y) \}}
\]
The premise (top) is matched against the current set of equations. If the match
is successful, the set of equations is replaced by the conclusion (bottom),
instantiated by the match. Some inference rules are \emph{conditional}, in
which case the condition must be checked before applying the rule.

For example, with the above rule and
the set of equations $\{ X \ueq cons(y_1, Z_1), \; X \ueq cons(y_2, Z_2) \}$,
we can derive the set of equations $\{ X \ueq cons(y_1, Z_1), \; y_2 \ueq y_1,
\; Z_2 \ueq Z_1 \}$. We could also derive the set of equations $\{ X \ueq
cons(y_2, Z_2), \; y_1 \ueq y_2, \; Z_1 \ueq Z_2 \}$, since the order of the
elements in the initial set is not fixed.

This is one example of the nondeterminism that can arise in the algorithm.
This particular inference rule is classified as ``don't care''-nondeterministic
in the system, which means the algorithm is free to choose either conclusion.
Some inference rules are classified ``don't know''-nondeterministic and require
branching. Fore more information about ``don't care'' and ``don't know'' rules,
as well as the full set of inference rules, see
Appendix~\ref{appendix:inference}.

\subsection{Dependency Graph}\label{subsection:graph}

The algorithm also makes use of a graph structure to detect occur-check failure
and $\Nil$-solutions. Given a set of equations $\EQ$, the \emph{list dependency
graph} is a directed graph $G_L(\EQ)$ whose nodes are the variables in $\X_L$ and
whose edges are given as follows:
\begin{enumerate}[(i)]
    \item For each equation $U \ueq \Cons(v, W)$ in $\EQ$, there is a directed
        edge from $U$ to $W$ labelled $>_{\Cons}$.
    \item For each equation $U \ueq \Bc(V, w)$ in $\EQ$, there is a directed
        edge from $U$ to $V$ labelled $>_{\Bc}$ and an \emph{undirected} edge
        between $U$ and $V$ labelled $\sim_{\Bc}$.
\end{enumerate}
We define the following two binary relations on $\X_L$ using the list dependency
graph $G_L(\EQ)$:
\begin{enumerate}[(i)]
    \item $U >_{\Bc}^+ V$ iff there is a path from $U$ to $V$ in $G_L(\EQ)$
        using \emph{only} edges labelled $>_{\Bc}$.

    \item $U \succ_L V$ iff there is a path from $U$ to $V$ in $G_L(\EQ)$ with
        \emph{at least} one edge labelled $>_{\Cons}$.
\end{enumerate}
Since two list variables connected by $\sim_{\Bc}$ must be assigned lists with
the same length by any unifier, $\succ_L$ can be interpreted as ``longer than.''

\subsection{The \texorpdfstring{$\Nonnil$}{nonnil} Set}
\label{subsection:nonnil}

The last data structure use by the algorithm is a set $\Nonnil \subseteq \X_L$
of variables that \emph{must not} be set to $\Nil$ in any unifier of $\EQ$. We
define $\Nonnil$ to be the smallest set such that the following conditions hold:
\begin{enumerate}[(i)]
    \item If $(U \ueq \Cons(v, W)) \in \EQ$, then $U \in \Nonnil$.
    \item If $(U \ueq \Bc(V, w)) \in \EQ$, then $U \in \Nonnil$ iff $V \in \Nonnil$.
    \item If $(U \ueq V) \in \EQ$, then $U \in \Nonnil$ iff $V \in \Nonnil$.
\end{enumerate}

\section{Maude Implementation}\label{section:maude}

Our implementation of the unification algorithm is written in the Maude
programming language, developed at the University of Illinois at
Urbana-Champaign. Maude, according to its website, is ``a high-performance
reflective language supporting both equation and rewriting logic
specification.'' This excellent support for reflective programming makes Maude
an attractive target for applications related to term-rewriting, because
implementors can turn Maude's powerful unification and rewriting capabilities
back on terms at the meta-level.

We assume the reader is familiar with Maude, including meta-level
programming~\cite{clavel2011maude}. (It could be argued that one cannot be
familiar with Maude \emph{unless} one is familiar with meta-level programming.)
Maude programs are built around \emph{modules}, which correspond to rewrite
systems in term-rewriting. Modules contain definitions of sorts, subsort
relationships, operators, sort membership axioms, equations, and rules.
Equations are assumed to be convergent when oriented from left to right, while
rules have no such restrictions.

As much as possible, our implementation is built around general-purpose
libraries rather than one-off solutions. To this end, there are a few important
modules that deserve their own description. The full source code for this
project is given in Appendix~\ref{appendix:implementation}.

\subsection{The \TitleListing{INFERENCE} Module}\label{subsection:inference-mod}

Maude's notion of a rule corresponds nicely with the inference rules described
previously. The main difference is that, while inference rules are applied
according to a precedence in a non-deterministic manner, Maude rules are applied
in a deterministic manner according to some strategy. The two built-in strategies
are a top-down rule-fair strategy (\lstinline|rewrite|) and bottom-up rule-fair
strategy (\lstinline|frewrite|). For our inference rules, nondeterminism is
crucial --- one branch of the algorithm may lead to failure while another may
find a unifier.

To solve this problem, we turn to what Maude calls \emph{internal strategies},
in which we use reflective programming to apply rules from a module in a manner
that we can control. The \lstinline|INFERENCE| module provides a strategy
\lstinline|inferenceRules| that applies rules (unconditional or conditional)
using a backtracking approach until either all branches fail or a successful
branch has no rule applicable to it.

To be recognized by this strategy, a rule must be labelled and must be tagged
with metadata describing its precedence and whether it is deterministic or
nondeterministic (corresponding to ``don't care'' and ``don't know,''
respectively). For example, the inference rule given in
Subsection~\ref{subsection:inference} is implemented in the module
\lstinline|BC-INFERENCE| by the rule:
\begin{lstlisting}[language=Maude, style=smalllisting]
    rl [cancel-cons] :
        bc-infer(U =? CONS[V, W] & U =? CONS[X, Y] & EQ,
                 BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? CONS[V, W] & X =? V & Y =? W & EQ,
                    BC H CONS NIL ELT LIST, N)
        [metadata "prec 3 det"] .
\end{lstlisting}
The metadata \lstinline|"prec 3 det"| indicates that this rule has precedence~3
(lower precedence rules are run more often) and that it deterministic (no
branching is required). The relative order of \lstinline|prec 3| and
\lstinline|det| is irrelevant.

As an example of a nondeterministic rule, here is another rule from
\lstinline|BC-INFERENCE|:
\begin{lstlisting}[language=Maude, style=smalllisting]
    rl [cancel-nondet] :
        bc-infer(U =? BC[V, W] & U =? BC[X, Y] & EQ,
                 BC H CONS NIL ELT LIST, N)
        => bc-infer(U =? BC[V, W] & X =? V & Y =? W & EQ,
                    BC H CONS NIL ELT LIST, N)
        [metadata "prec 8 nondet"] .
\end{lstlisting}
This rule guesses that two $\Bc$-equations can be decomposed, but may fail. Its
metadata contains \lstinline|nondet| to indicate that backtracking is required.

The \lstinline|inferenceRules| operation has the following signature:
\begin{lstlisting}[language=Maude, style=smalllisting]
    op inferenceRules : Module Term Term Nat -> [Term] .
\end{lstlisting}
It takes as its arguments a meta-representation of the module module in which
to rewrite, a term representing the object to be rewritten, a term representing
failure, and natural number indicating the number of solutions to skip. This
last argument is required because \lstinline|inferenceRules| is what Maude
calls a \emph{descent function}. Rather than return all solutions at once, the
caller specifies which solution is desired. Note that
\lstinline|inferenceRules| is a partial function (its range is a kind); the
operation is undefined if, for example, the module argument does not represent
a valid module.

\subsection{The \TitleListing{GRAPH} and \TitleListing{META-GRAPH} Modules}
\label{subsection:graph-mod}

In order to implement the list dependency graph and cycle-checking, we need an
implementation of graphs in Maude. Such an implementation should allow us to
associate with edges arbitrary data (e.g., labels), and edges should be able to
be directed and undirected (possibly within the same graph). Our solution is to
parameterize graphs by the edges they contain. We define a theory
\lstinline|EDGE| with the following sort declarations:
\begin{lstlisting}[language=Maude, style=smalllisting]
    sorts Node Edge NodeSet NeNodeSet .
    subsorts Node < NeNodeSet < NodeSet .
\end{lstlisting}
In addition to these four sorts (and appropriate constructors for the sets),
the \lstinline|EDGE| theory defines three destructor operations:
\begin{lstlisting}[language=Maude, style=smalllisting]
    op from : Edge Node -> Bool .
    op to : Edge Node -> Bool .
    op nodes : Edge -> NeNodeSet .
\end{lstlisting}

The first two are relations that detect if the edge is to or from the given
node, respectively. The second evaluates to a set containing \emph{al{}l} nodes
in the edge, regardless of whether it is to or from a particular node.  The
module \lstinline|GRAPH{E :: EDGE}| then defines graphs and paths in terms of
edges and nodes.

Graphs are defined as sets of edges. Note that Maude does not currently support
mixing the \lstinline|assoc| (associative) and \lstinline|idem| (idempotent)
attributes for operators, so we declare \lstinline!_||_! with \lstinline|assoc|
and implement idempotency as an equation.
\begin{lstlisting}[language=Maude, style=smalllisting]
    sorts Graph{E} NeGraph{E} .
    subsorts E$Edge < NeGraph{E} < Graph{E} .

    op emptygraph : -> Graph{E} [ctor] .

    op _||_ : Graph{E} Graph{E} -> Graph{E}
        [assoc comm ctor id: emptygraph prec 80
        format (d r os d)] .
    op _||_ : NeGraph{E} Graph{E} -> NeGraph{E}
        [ctor ditto] .
\end{lstlisting}

Paths are defined as sequences of edges. Membership axioms are used to ensure
the sequence of edges is a valid path; if \lstinline|E1 E2| is a subsequence of
a path, there must be at least one node \lstinline|N| such that
\lstinline|to(E1, N)| and \lstinline|from(E2, N)|.
\begin{lstlisting}[language=Maude, style=smalllisting]
    sorts Path{E} NePath{E} Path?{E} .
    subsorts E$Edge < NePath{E} < Path{E} < Path?{E} .

    op noPath : -> Path?{E} [ctor] .

    op emptypath : -> Path{E} [ctor] .
    op __ : [Path{E}] [Path{E}] -> [Path{E}]
        [ctor assoc id: emptypath] .
\end{lstlisting}

The \lstinline|GRAPH{E :: EDGE}| module provides three useful operations on
graphs related to paths and cycles:
\begin{lstlisting}[language=Maude, style=smalllisting]
    op findPath : E$Node E$Node Graph{E} Nat -> Path?{E} .
    op findNePath : E$Node E$Node Graph{E} Nat -> Path?{E} .
    op hasCycle : Graph{E} -> Bool .
\end{lstlisting}
The first two search for paths in the graph from the first node to the second.
These operations are descent functions, so they take as their last argument the
number of solutions to skip. The third operation checks if the given graph has
a cycle --- i.e., a non-empty path from a node back to itself.

The \lstinline|META-GRAPH{E :: EDGE}| module extends the \lstinline|GRAPH|
module by allowing the path-searching and cycle-searching operations to check
conditions and possibly reject paths. It provides extended versions of the
three operations above:
\begin{lstlisting}[language=Maude, style=smalllisting]
    op findPath : E$Node E$Node Graph{E} Module Context Nat -> Path?{E} .
    op findNePath : E$Node E$Node Graph{E} Module Context Nat -> Path?{E} .
    op hasCycle : Graph{E} Module Context -> Bool .
\end{lstlisting}
The context and module are used to implement the condition. The context will be
applied to the meta-representation of the current path candidate, and the
resulting term will be rewritten at the meta-level in the given module. If the
result is \lstinline|true|, then the path is a solution. Otherwise it is
discarded.

\subsection{The \TitleListing{UNIFICATION-ALGORITHM} Theory}
\label{subsection:unif-alg-mod}

We provide a theory, \lstinline|UNIFICATION-ALGORITHM|, which formalizes the
interface we expect for the unification algorithm for the element theory. The
operator \lstinline|unify-alg| has the same signature as \lstinline|metaUnify|
from the \lstinline|META-LEVEL| module, and in fact there is a view
\lstinline|MetaUnifyAlg| from \lstinline|META-LEVEL| to
\lstinline|UNIFICATION-ALGORITHM| with exactly that mapping.

\subsection{The \TitleListing{BC-UNIFICATION} Module}
\label{subsection:bc-unif-mod}

This module is the heart of the project. It uses the \lstinline|inferenceRules|
strategy from \lstinline|INFERENCE| to apply the inference rules implemented
in \lstinline|BC-INFERENCE|. The unification operator is called
\lstinline|bc-unify|, which takes as arguments a
\lstinline|UnificationProblem|, a meta-representation of a view from
\lstinline|BC|, and two numbers, representing respectively the largest number
of a new variable in the problem (e.g., \lstinline|'#6:Elt|) and the skip
counter for the descent function. Note that the unification problem given
to \lstinline|bc-unify| need not be given in standard form; it can be any set
of equations over the signature.

The \lstinline|View| parameter must be the meta-representation of a view from
\lstinline|BC| to the user's module. It is assumed that the view is in the
system \emph{at the object level}. To the best of our knowledge, Maude does not
have any feature for instantiating a parameterized module with a view that only
exists at the meta-level.

From the view, we extract a signature, which contains the names of the symbols
for $\Bc$, $\Hh$, $\Cons$, $\Nil$, $\Elt$, and $\List$. A module
\lstinline|BC-SIGNATURE| is provided with the default names for these symbols,
as well as a view \lstinline|BcSignature| from \lstinline|BC| to
\lstinline|BC-SIGNATURE|. The view is also used to find the module in which the
second phase of our algorithm --- solving the element equations --- will be
performed. The ``to'' module of the view will be passed to the unification
algorithm for the element theory.

For examples of using \lstinline|bc-unify| and the \lstinline|BC-UNIFICATION|
module, see Appendix~\ref{appendix:samples}.

\section{Conclusion}\label{section:conclusion}

We have explored an algorithm for solving unification problems modulo a theory
of chaining, where the theory $\BC$ is combined with an element theory $\HH$.
The algorithm first solves the list equations by transforming them into a
solved form, then uses a provided unification algorithm to solve the element
equations. We provided an implementation of this algorithm in the Maude
programming language. More information about the algorithm and its
implementation are provided in the appendices.

There are several opportunities for future work on this project. The descent
functions, e.g., for path-finding, currently recompute skipped solutions (i.e.,
they start from scratch each time). There is an opportunity for a speed-up by
memoizing their results, but the code as written will not benefit from
memoization. They could be rewritten if this speed-up is desired.

Also, currently the list dependency graph and $\Nonnil$ set are re-computed
each time they are needed. The \lstinline|bc-infer| operation in the
\lstinline|BC-INFERENCE| module could be extended to keep these data structures
as it runs, allowing them to be updated rather than recomputed.

Finally, an extended algorithm has been developed for solving unification
problems modulo a related theory with a ``de-chaining'' operator, which could
model cipher block chaining with a list-level decryption operator. Implementing
this algorithm should only require an extended set of inference rules and a
more complicated list dependency graph.

Currently there is at least one attack on cipher block chaining in the wild.
The ``BEAST'' attack on TLS, developed in 2010 by Duong and Rizzo, abuses the
fact that TLS 1.0 allows implementations to use the last encrypted block of the
previous record as the initialization vector of the next, rather than
generating a new initialization vector for each
record~\cite{rizzo2010practical, ekr2011security}. It is our hope that, through
symbolic protocol analysis, we will uncover more attacks like this in an
automated way.

\clearpage
\bibliography{bc-unification}

\clearpage
\appendix

\section{Inference Rules}\label{appendix:inference}

Here is the complete system of inference rules for transforming a set of list
equations into dag-solved form. The rules come in two types: ``don't
care''-nondeterministic and ``don't know''-nondeterministic. The difference
is that when more than one ``don't care'' rule is applicable to the same
set of equations, a rule may be picked arbitrarily. When more than one ``don't
know'' rule is applicable, any could be applied. The algorithm must branch at
this point.

Some rules have variables in their conclusions that do not occur in their
premise. These are called \emph{fresh variables}, and should be instantiated
with new variables that do not occur in the equations.

\subsection{\texorpdfstring{``Don't Care''}{"Don't Care"}-Nondeterministic Rules}

The following rules are ``don't care''-nondeterministic. In theory, these rules
can be applied in any order without changing the space of solutions. In practice
(and in our implementation) we apply rules according to a precedence order to
ensure termination.
\begin{enumerate}[(L1), align=left, font=\bfseries]
    \item \emph{Variable Elimination}:
        \[\infer[\quad \text{if } U \text{ occurs in } \EQ ]
            {\; [V/U](\EQ) ~ \cup ~ \{U \ueq V\} \;}
            {\; \EQ ~ \uplus ~ \{U \ueq V\} \;}
        \]

    \item \emph{Cancellation on $\Cons$}:
        \[\infer
            {\; \EQ ~ \cup ~ \{ U \ueq cons(v, W), \; x \ueq v, \; Y \ueq W \} \;}
            {\; \EQ ~ \uplus ~ \{ U \ueq cons(v, W), \; U \ueq cons(x, Y) \} \;}
        \]
\end{enumerate}
\begin{enumerate}[(L3.a), align=left, font=\bfseries]
    \item \emph{Nil solution-1}:
        \[\infer
            {\; \EQ ~ \cup ~ \{ U \ueq nil, \; V \ueq nil \} \;}
            {\; \EQ ~ \uplus ~ \{ U \ueq bc(V, w), \; U \ueq nil \} \;}
        \]

    \item \emph{Nil solution-2}:
        \[\infer
            {\; \EQ ~ \cup ~ \{ U \ueq nil, \; V \ueq nil \} \;}
            {\; \EQ ~ \uplus ~ \{ U \ueq bc(V, w), \; V \ueq nil \} \;}
        \]

    \item \emph{Nil solution-3}:
        \[\infer[\quad \mathrm{if} ~ V >_{bc}^{+} U ]
            {\; \EQ ~ \cup ~ \{ U \ueq nil, \; V \ueq nil \} \;}
            {\; \EQ ~ \uplus ~ \{ U \ueq bc(V, w) \} \;}
        \]
\end{enumerate}
\begin{enumerate}[(L4.a), align=left, font=\bfseries]
    \item \emph{Semi-Cancellation on $\Bc$}, at a $\Bc/\Bc$-peak:
        \[\infer
            {\; \EQ ~ \cup ~ \{U \ueq bc(V, w), \; W \ueq V \} \;}
            {\; \EQ ~ \uplus ~ \{ U \ueq bc(V, w), \; U \ueq bc(X, w) \} \;}
        \]

    \item \emph{Push $\Bc$ below $\Cons$}, at a $\Nonnil$ $\Bc/\Bc$-peak:
        \[\infer[\quad \text{if } U \in \Nonnil]
            {\; \begin{aligned}
                \EQ ~ \cup ~ \{
                & V \ueq cons(v', Z), \; X \ueq cons(x', Z), \;
                  U \ueq cons(u', U''), \\[-4pt]
                & U'' \ueq bc(Z, u'), \; u' \ueq h(v', w), \;
                  u' \ueq h(x', y) \}
            \end{aligned} \;}
            {\; \EQ ~ \uplus ~ \{ U \ueq bc(V, w), \; U \ueq bc(X, y) \} \;}
        \]
\end{enumerate}
\begin{enumerate}[(L1), align=left, font=\bfseries, start=5]
    \item \emph{Splitting}, at a $\Cons/\Bc$-peak:
        \[\infer
        {\; \EQ ~ \cup ~ \{ U \ueq cons(v, W) , \; X \ueq cons(x', X''), \;
              W \ueq bc(X'', v), \; v \ueq h(x', y) \} \;}
        {\; \EQ ~ \uplus ~ \{ U \ueq cons(v, W), \; U \ueq bc(X, y) \} \;}
        \]

    \item \emph{Occur-Check Violation}:
        \[\infer[\quad \text{if } U \text{ occurs in } \EQ
                 \text{ and }  U \succ_L U]
            {\; \Fail \;}
            {\; \EQ \;}
        \]

    \item \emph{Size Conflict}:
        \[\infer
            {\; \Fail \;}
            {\; \EQ ~ \uplus ~ \{ U \ueq cons(v, W), \; U \ueq nil \} \;}
        \]
\end{enumerate}

\subsection{\texorpdfstring{``Don't Know''}{"Don't Know"}-Nondeterministic Rules}

The remaining rules are ``don't know''-nondeterministic. Different orders of
application will lead to different unifiers. A complete set of unifiers can
be obtained by trying all branches.
\begin{enumerate}[(L1), align=left, font=\bfseries, start=8]
    \item \emph{Nil-solution-Branch for $\Bc$}, at a $\Bc/\Bc$-peak:
        \[\infer
            {\; \EQ ~ \cup ~ \{ U \ueq nil, \; V \ueq nil, \; X \ueq nil \} \;}
            {\; \EQ ~ \uplus ~ \{ U \ueq bc(V, w), \; U \ueq bc(X, y) \} \;}
        \]

    \item \emph{Guess a non-Nil branch for $\Bc$}, at a $\Bc/\Bc$-peak:
        \[\infer
            {\; \begin{aligned}
                \EQ ~ \cup ~ \{
                & V \ueq cons(v', Z), \; X \ueq cons(x', Z), \;
                  U \ueq cons(u', U''), \\[-4pt]
                & U'' \ueq bc(Z, u'), \; u' \ueq h(v', w), \;
                  u' \ueq h(x', y) \}
            \end{aligned} \;}
            {\; \EQ ~ \uplus ~ \{ U \ueq bc(V, w), \; U \ueq bc(X, y) \} \;}
        \]

    \item \emph{Standard Unification on $\Bc$}:
        \[\infer
            {\; \EQ ~ \cup ~ \{ U \ueq bc(V, w), \; X \ueq V, \; y \ueq w \} \;}
            {\; \EQ ~ \uplus ~ \{ U \ueq bc(V, w), \; U \ueq bc(X, y) \} \;}
        \]
\end{enumerate}

\subsection{Additional Rules}

There are two additional inference rules in our implementation that do not
appear in ``Unification modulo Chaining,'' where they are simply assumed. The
first rule is unique in that it contains a ``term variable,'' which can be
matched against any term (to avoid having an instance for each symbol in the
signature). Note also that in the first rule, $\EQ$ is treated as a multiset.
This is true of all inference rules in our implementation, which is why the
rule is required.
\begin{enumerate}[(L{1}.a), align=left, font=\bfseries, start=2]
    \item \emph{Repetition Elimination}:
        \[\infer
            {\; \EQ ~ \cup ~ \{U \ueq t\} \;}
            {\; \EQ ~ \uplus ~ \{U \ueq t, \; U \ueq t\} \;}
        \]

    \item \emph{Trivial Elimination}:
        \[\infer
            {\; \EQ \;}
            {\; \EQ ~ \uplus ~ \{U \ueq U\} \;}
        \]
\end{enumerate}

\newpage
\section{Implementation}\label{appendix:implementation}

This appendix contains the \emph{complete} Maude code of this implementation.
It was written and tested in Maude 2.6 on a netbook running Gentoo GNU/Linux.
Some sample sessions are provided in Appendix~\ref{appendix:samples}. The
newest version of this report and code is available on GitHub at
\url{https://github.com/chrisbouchard/bc-unify/}.

\subsection{\TitleListing{tools.maude}}
\label{subappendix:tools-mod}
\lstinputlisting[language=Maude, style=smalllisting]{tools.maude}
\clearpage

\subsection{\TitleListing{apply.maude}}
\label{subappendix:apply-mod}
\lstinputlisting[language=Maude, style=smalllisting]{apply.maude}
\clearpage

\subsection{\TitleListing{inference.maude}}
\label{subappendix:inference-mod}
\lstinputlisting[language=Maude, style=smalllisting]{inference.maude}
\clearpage

\subsection{\TitleListing{graph.maude}}
\label{subappendix:graph-mod}
\lstinputlisting[language=Maude, style=smalllisting]{graph.maude}
\clearpage

\subsection{\TitleListing{unificand-set.maude}}
\label{subappendix:unificand-set-mod}
\lstinputlisting[language=Maude, style=smalllisting]{unificand-set.maude}
\clearpage

\subsection{\TitleListing{unification-algorithm.maude}}
\label{subappendix:unif-alg-theory}
\lstinputlisting[language=Maude, style=smalllisting]{unification-algorithm.maude}
\clearpage

\subsection{\TitleListing{bc-unification.maude}}
\label{subappendix:bc-unif-mod}
\lstinputlisting[language=Maude, style=smalllisting]{bc-unification.maude}
\clearpage

\subsection{\TitleListing{bc-test.maude}}
\label{subappendix:test-mod}
\lstinputlisting[language=Maude, style=smalllisting]{bc-test.maude}

\clearpage
\section{Sample Sessions}\label{appendix:samples}

In this appendix some examples will be given of interacting with this project.
There are two main entry points: the \lstinline|BC-UNIFICATION| module, or the
\lstinline|TEST-BC-UNIFICATION| module. The former contains the actual
$\BC$-unification operation: \lstinline|bc-unify|. The latter contains several
predefined instances of $\BC$-unification for testing purposes.

In the following examples, input will be given in \lstinline|@/italics/@|. The
examples in sections~\ref{subappendix:using-bc-unif-mod}
and~\ref{subappendix:using-bc-test-mod} assume Maude 2.6 has been started and
all the source files have been \lstinline|load|ed.

\subsection{Loading the Project into Maude}\label{subappendix:loading}

Each source file in this project \lstinline|load|s the other source files that
it needs. This leads to most modules being redefined or reparsed at least once
(and common modules, such as \lstinline|TOOLS|, may be redefined several
times). This is okay because it only needs to be done once when the project is
loaded. The process could be streamlined by having one file act as master and
\lstinline|load| the other files in the correct order, but we have decided to
err in favor of modularity.
\vspace{1ex}

\lstinputlisting[style=smalllisting]{load-bc-unify.txt}

\subsection{Using \TitleListing{BC-UNIFICATION} and \TitleListing{bc-unify}}
\label{subappendix:using-bc-unif-mod}

The \lstinline|bc-unify| operation takes as arguments a
\lstinline|UnificationProblem|, a meta-representation of a view, and two
numbers, representing respectively the largest number of a new variable in the
problem (e.g., \lstinline|'#6:Elt|) and the skip counter for the descent
function. Unfortunately, we cannot rewrite interactively in the
\lstinline|BC-UNIFICATION| module, because it is parameterized. It is more
correctly called \lstinline|BC-UNIFICATION{ALG :: UNIFICATION-ALGORITHM}|.

\subsection{Using \TitleListing{TEST-BC-UNIFICATION}}
\label{subappendix:using-bc-test-mod}

For interactive testing, the \lstinline|TEST-BC-UNIFICATION| module provides a
version of \lstinline|BC-UNIFICATION| instantiated with the view
\lstinline|MetaUnifyAlg|, which uses the built-in unification operation
\lstinline|metaUnify| from \lstinline|META-LEVEL|. The problem is given as
set of equations separated by \lstinline|/\| (slash-backslash or ``wedge'').
Equations are given as a pair of terms separated by \lstinline|=?|
(equals-question-mark).

The view must be a meta-representation of an object-level view (i.e., it must
be in the system). A view can be raised to the meta-level by use of the
following operator:
\begin{lstlisting}[language=Maude, style=smalllisting]
    op upView : [Qid] -> [View] [special (...)] .
\end{lstlisting}
where the \lstinline|Qid| parameter is the name of the view.

Here is an example of two calls to \lstinline|bc-unify|:
\vspace{1ex}
\lstinputlisting[style=smalllisting]{bc-test-op-example.txt}
When we ask for the first solution (zero solutions skipped), a unifier is
returned. However, when we ask for the next solution, the result is
\lstinline|noUnifier|, which signifies that there are no more solutions.  Thus
this problem has a single most-general unifier.  Note that the problem is not
given in standard form; our implementation decomposes the input into standard
form before running the algorithm. Any newly-created variables are removed from
the domain of the returned unifier, so this decomposition is transparent to the
user.

The \lstinline|TEST-BC-UNIFICATION| module also defines some simple
$\BC$-unification problems for testing. For example, there is an operator
\begin{lstlisting}[language=Maude, style=smalllisting]
    op test-cancel-cons : -> UnificationPair? .
    eq test-cancel-cons =
        bc-unify('U:List =? 'cons['V:Elt, 'W:List] /\
                 'U:List =? 'cons['X:Elt, 'Y:List],
                 testView, 0, 0) .
\end{lstlisting}
To try this input, we simply \lstinline|reduce| the operator:
\vspace{1ex}

\lstinputlisting[style=smalllisting]{bc-test-pre-example.txt}
\vspace{1ex}

The only non-constant test operation in \lstinline|TEST-BC-UNIFICATION| is
\begin{lstlisting}[language=Maude, style=smalllisting]
    op test-nondet_ : Nat -> UnificationPair? .
    eq test-nondet N =
        bc-unify('U:List =? 'bc['V:List, 'W:Elt] /\
                 'U:List =? 'bc['X:List, 'Y:Elt],
                 testView, 0, N) .
\end{lstlisting}
which tests the non-deterministic rules. The number is passed to
\lstinline|bc-unify| as its skip parameter.
\vspace{1ex}
\lstinputlisting[style=smalllisting]{test-nondet-example.txt}
Each unifier is returned twice in this case, because there are two different
ways to apply each ``don't know'' rule. Our implementation does not attempt to
suppress duplicated unifiers.

\end{document}

