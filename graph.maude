fth EDGE is
    protecting BOOL .

    sorts Node Edge NodeSet NeNodeSet .
    subsorts Node < NeNodeSet < NodeSet .

    op emptyset : -> NodeSet [ctor] .
    op __ : NodeSet NodeSet -> NodeSet
        [ctor assoc comm id: emptyset] .
    op __ : NeNodeSet NodeSet -> NeNodeSet
        [ctor ditto] .

    --- NodeSets are idempotent, but we can't mix the assoc, comm, and idem
    --- attributes.
    eq N:Node N:Node = N:Node [nonexec] .

    op from : Edge Node -> Bool .
    op to : Edge Node -> Bool .
    op nodes : Edge -> NeNodeSet .
endfth

fmod GRAPH{E :: EDGE} is
    protecting NAT .

    *** Define the Graph sort and its related subsorts and constructors.
    sorts Graph{E} NeGraph{E} .
    subsorts E$Edge < NeGraph{E} < Graph{E} .

    op emptygraph : -> Graph{E} [ctor] .

    op _||_ : Graph{E} Graph{E} -> Graph{E}
        [assoc comm ctor id: emptygraph prec 80 format (d r os d)] .
    op _||_ : NeGraph{E} Graph{E} -> NeGraph{E}
        [ctor ditto] .


    *** Define the Path sort and its related subsorts and constructors. We
    *** also provide a maybe type Path? to indicate failure to compute a path.
    sorts Path{E} NePath{E} Path?{E} .
    subsorts E$Edge < NePath{E} < Path{E} < Path?{E} .

    op noPath : -> Path?{E} [ctor] .

    --- We only define the [Path{E}] kind for now. We'll use membership axioms
    --- below to define the sort.
    op emptypath : -> Path{E} [ctor] .
    op __ : [Path{E}] [Path{E}] -> [Path{E}] [ctor assoc id: emptypath] .


    *** Define lists of graphs, which is mainly intended as an internal data
    *** structure. We use these to implement a tail-recursive, backtracking
    *** search for paths.
    sorts GraphList{E} .
    subsorts Graph{E} < GraphList{E} .

    op nil : -> GraphList{E} [ctor] .
    op _;_ : GraphList{E} GraphList{E} -> GraphList{E}
        [ctor assoc id: nil prec 82] .


    vars E E' E1 E2 : E$Edge .
    vars G G' G'' : Graph{E} .
    vars N1 N2 N3 : E$Node .
    vars N NS ND NC : E$Node .
    vars P P1 P1' P2 P2' : Path{E} .
    vars P? : Path?{E} .
    vars NEP : NePath{E} .
    vars GL : GraphList{E} .
    vars SKIP : Nat .
    vars S S1 S2 : E$NodeSet .


    *** The edges in a path have to match up end to end.
    cmb NEP E2 : NePath{E}
        if P E1 := NEP
        /\ N1 N2 S1 := nodes(E1) /\ N2 N3 S2 := nodes(E2)
        /\ to(E1, N2) /\ from(E2, N2) .


    --- Graphs are idempotent, but we can't mix the assoc, comm, and idem
    --- attributes.
    eq E || E = E .


    op graphnodes : Graph{E} -> E$NodeSet .
    op graphnodes : NeGraph{E} -> E$NeNodeSet .
    eq graphnodes(emptygraph) = emptyset .
    eq graphnodes(E || G) = nodes(E) graphnodes(G) .


    op hasCycle : Graph{E} -> Bool .
    ceq hasCycle(G) = true
        if N S := graphnodes(G) /\ noPath =/= findNePath(N, N, G, 0) .
    eq hasCycle(G) = false [owise] .


    op getSubgraphFrom : E$NodeSet Graph{E} -> Graph{E} .
    eq getSubgraphFrom(N S, E || G) =
        (if from(E, N) then E else emptygraph fi) || getSubgraphFrom(N S, G) .
    eq getSubgraphFrom(N, emptygraph) = emptygraph .

    op getSubgraphTo : E$NodeSet Graph{E} -> Graph{E} .
    eq getSubgraphTo(N S, E || G) =
        (if to(E, N) then E else emptygraph fi) || getSubgraphTo(N S, G) .
    eq getSubgraphTo(N, emptygraph) = emptygraph .


    op findPath : E$Node E$Node Graph{E} Nat -> Path?{E} .
    eq findPath(N, N, G, SKIP) =
        if SKIP == 0
            then emptypath
            else findNePath(N, N, G, sd(SKIP, 1))
        fi .
    eq findPath(NS, ND, G, SKIP) = findNePath(NS, ND, G, SKIP) [owise] .

    op findNePath : E$Node E$Node NeGraph{E} Nat -> Path?{E} .
    eq findNePath(NS, ND, G, SKIP) =
        $findNePath(NS, NS, ND, emptypath, nil, G, SKIP) .

    --- We keep the set of applicable nodes for each step in the path. Could
    --- this be replaced with a skip counter? We'd need some way to order the
    --- edges internally.
    op $findNePath : E$Node E$Node E$Node Path{E} GraphList{E} Graph{E} Nat
                     -> Path?{E} .
    ceq $findNePath(NS, NC, ND, P, GL, G, SKIP) =
        $findNePath(NS, N, ND, P E, (GL ; G'), G'', SKIP)
        if NC =/= ND /\ E || G' := getSubgraphFrom(NC, G)
        /\ NC N S := nodes(E) /\ from(E, NC) /\ to(E, N)
        /\ E || G'' := G .
    ceq $findNePath(NS, NC, ND, P, GL, G, SKIP) =
        $revertNePath(NS, NC, ND, P, GL, G, SKIP)
        if NC =/= ND /\ emptygraph := getSubgraphFrom(NC, G) .
    eq $findNePath(NS, ND, ND, P, GL, G, SKIP) =
        if SKIP == 0
            then P
            else $revertNePath(NS, ND, ND, P, GL, G, sd(SKIP, 1))
        fi .

    op $revertNePath : E$Node E$Node E$Node Path{E} GraphList{E} Graph{E} Nat
                       -> Path?{E} .
    ceq $revertNePath(NS, NC, ND, P E, (GL ; G' || E'), G, SKIP) =
        $findNePath(NS, N2, ND, P E', (GL ; G'), G'', SKIP)
        if N1 NC S1 := nodes(E) /\ N1 N2 S2 := nodes(E')
        /\ from(E, N1) /\ from(E', N1) /\ to(E', N2)
        /\ E' || G'' := G || E .
    ceq $revertNePath(NS, NC, ND, P E, (GL ; emptygraph), G, SKIP) =
        $revertNePath(NS, N, ND, P, GL, G || E, SKIP)
        if N NC S := nodes(E) /\ from(E, N) .
    eq $revertNePath(NS, NC, ND, P, nil, G, SKIP) = noPath .
endfm


*** It's useful to have graphs of Qids, so we pre-define them.

fmod SIMPLE-SET{X :: TRIV} is
    sorts NodeSet{X} NeNodeSet{X} .
    subsorts X$Elt < NeNodeSet{X} < NodeSet{X} .

    op emptyset : -> NodeSet{X} [ctor] .
    op __ : NodeSet{X} NodeSet{X} -> NodeSet{X}
        [ctor assoc comm id: emptyset] .
    op __ : NeNodeSet{X} NodeSet{X} -> NeNodeSet{X}
        [ctor ditto] .

    --- SimpleSets are idempotent, but we can't mix the assoc, comm, and idem
    --- attributes.
    eq N:X$Elt N:X$Elt = N:X$Elt .
endfm

fmod QID-EDGE is
    protecting SIMPLE-SET{Qid} * (sort NodeSet{Qid} to QidSet,
                                  sort NeNodeSet{Qid} to NeQidSet) .

    sorts QidEdge .

    op qe : Qid Qid -> QidEdge [ctor] .
    op qe : Qid Qid Qid -> QidEdge [ctor] .

    vars Q Q1 Q2 Q3 : Qid .
    vars E : QidEdge .

    op from : QidEdge Qid -> Bool .
    eq from(qe(Q1, Q2), Q1) = true .
    eq from(qe(Q1, Q2, Q3), Q1) = true .
    eq from(E, Q) = false [owise] .

    op to : QidEdge Qid -> Bool .
    eq to(qe(Q1, Q2), Q2) = true .
    eq to(qe(Q1, Q2, Q3), Q2) = true .
    eq to(E, Q) = false [owise] .

    op nodes : QidEdge -> QidSet .
    eq nodes(qe(Q1, Q2)) = Q1 Q2 .
    eq nodes(qe(Q1, Q2, Q3)) = Q1 Q2 .
endfm

view QidEdge from EDGE to QID-EDGE is
    sort Node to Qid .
    sort Edge to QidEdge .
    sort NodeSet to QidSet .
    sort NeNodeSet to NeQidSet .
endv

fmod QID-GRAPH is
    protecting GRAPH{QidEdge}
        * (sort Graph{QidEdge} to QidGraph,
           sort NeGraph{QidEdge} to NeQidGraph,
           sort Path{QidEdge} to QidPath,
           sort NePath{QidEdge} to NeQidPath,
           sort Path?{QidEdge} to QidPath?,
           sort NePath?{QidEdge} to NeQidPath?) .
endfm

