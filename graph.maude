fth EDGE is
    protecting BOOL .

    sorts Edge Node NodePair .

    op __ : Node Node -> NodePair [ctor comm] .

    op from : Edge Node -> Bool .
    op to : Edge Node -> Bool .
    op nodes : Edge -> NodePair .
endfth

fmod QID-EDGE is
    protecting QID .

    sorts QidEdge QidPair .

    op qe : Qid Qid -> QidEdge [ctor] .
    op qe : Qid Qid Qid -> QidEdge [ctor] .

    op qp : Qid Qid -> QidPair [ctor comm] .

    vars Q Q1 Q2 Q3 : Qid .
    vars E : QidEdge .

    op from : QidEdge Qid -> Bool .
    eq from(qe(Q1, Q2), Q1) = true .
    eq from(qe(Q1, Q2, Q3), Q1) = true .
    eq from(E, Q) = false [owise] .

    op to : QidEdge Qid -> Bool .
    eq to(qe(Q1, Q2), Q2) = true .
    eq to(qe(Q1, Q2, Q3), Q2) = true .
    eq to(E, Q) = false [owise] .

    op nodes : QidEdge -> QidPair .
    eq nodes(qe(Q1, Q2)) = qp(Q1, Q2) .
    eq nodes(qe(Q1, Q2, Q3)) = qp(Q1, Q2) .
endfm

view QidEdge from EDGE to QID-EDGE is
    sort Edge to QidEdge .
    sort Node to Qid .
    sort NodePair to QidPair .

    op __ to qp .
endv

fmod GRAPH{E :: EDGE} is
    sorts Graph{E} NeGraph{E} .
    subsorts E$Edge < NeGraph{E} < Graph{E} .

    sorts NodeSet{E} NeNodeSet{E} .
    subsorts E$Node < NeNodeSet{E} < NodeSet{E} .
    ---subsorts E$NodePair < NeNodeSet{E} .

    op emptygraph : -> Graph{E} [ctor] .

    op _||_ : Graph{E} Graph{E} -> Graph{E}
        [assoc comm ctor id: emptygraph prec 80 format (d r os d)] .
    op _||_ : NeGraph{E} Graph{E} -> NeGraph{E}
        [ctor ditto] .

    op emptyset : -> NodeSet{E} [ctor] .
    op _,_ : NodeSet{E} NodeSet{E} -> NodeSet{E}
        [assoc comm ctor id: emptyset] .
    op _,_ : NeNodeSet{E} NodeSet{E} -> NeNodeSet{E}
        [ctor ditto] .

    vars A B : E$Edge .
    vars G H : Graph{E} .
    vars N M O : E$Node .
    vars S T : NodeSet{E} .

    eq A || A = A .
    eq N, N = N .

    op graphnodes : Graph{E} -> NodeSet{E} .
    op graphnodes : NeGraph{E} -> NeNodeSet{E} .
    op graphnodes : E$NodePair -> NeNodeSet{E} .
    eq graphnodes(emptygraph) = emptyset .
    eq graphnodes(A || G) = graphnodes(nodes(A)), graphnodes(G) .
    eq graphnodes(N M) = N, M .

    op sources : Graph{E} -> NodeSet{E} .
    eq sources(emptygraph) = emptyset .
    eq sources(emptygraph) = emptyset .
    eq sources(G) = $sources(G, graphnodes(G)) .

    op $sources : Graph{E} NodeSet{E} -> NodeSet{E} .
    ceq $sources((A || G), (N, S)) = $sources(G, S) if to(A, N) .
    eq $sources(G, S) = S [owise] .

    op sinks : Graph{E} -> NodeSet{E} .
    eq sinks(emptygraph) = emptyset .
    eq sinks(G) = $sinks(G, graphnodes(G)) .

    op $sinks : Graph{E} NodeSet{E} -> NodeSet{E} .
    ceq $sinks((A || G), (N, S)) = $sinks(G, S) if from(A, N) .
    eq $sinks(G, S) = S [owise] .

    --- Delete the set of nodes in the first argument from the graph in the
    --- second argument.
    op delete : NodeSet{E} Graph{E} -> Graph{E} .
    eq delete((N, S), G) = delete(S, $delete(N, G)) .
    eq delete(emptyset, G) = G .

    op $delete : E$Node Graph{E} -> Graph{E} .
    eq $delete(N, emptygraph) = emptygraph .
    ceq $delete(N, (A || G)) = A || delete(N, G)
        if not from(A, N) /\ not to(A, N) .
    eq $delete(N, (A || G)) = delete(N, G) [owise] .

    op hascycle : Graph{E} -> Bool .
    eq hascycle(emptygraph) = false .
    eq hascycle(G) = $hascycle(G, sources(G), sinks(G)) [owise] .

    op $hascycle : Graph{E} NodeSet{E} NodeSet{E} -> Bool .
    eq $hascycle(G, S, emptyset) = true .
    eq $hascycle(G, emptyset, T) = true .
    eq $hascycle(G, S, T) = hascycle(delete((S, T), G)) .
endfm

fmod GRAPH-PATH{E :: EDGE} is
    protecting GRAPH{E} .

    sorts Path{E} NePath{E} Path?{E} NePath?{E} .
    subsorts E$Edge < NePath{E} < Path{E} NePath?{E} < Path?{E} .

    op noPath : -> Path?{E} [ctor] .
    op noNePath : -> NePath?{E} [ctor] .

    *** We only define the [Path{E}] kind for now. We'll use membership axioms
    *** below to define the sort.
    op emptypath : -> Path{E} [ctor] .
    op __ : [Path{E}] [Path{E}] -> [Path{E}] [ctor assoc id: emptypath] .

    vars E E1 E2 : E$Edge .
    vars G : Graph{E} .
    vars N1 N2 N3 : E$Node .
    vars N NS ND : E$Node .
    vars P P1 P1' P2 P2' : Path{E} .
    vars P? : Path?{E} .
    vars NEP : NePath{E} .

    cmb NEP E2 : NePath{E}
        if P E1 := NEP
        /\ N1 N2 := nodes(E1) /\ N2 N3 := nodes(E2)
        /\ to(E1, N2) /\ from(E2, N2) .

    op findPath : E$Node E$Node Graph{E} -> Path{E} .
    eq findPath(N, N, G) = emptypath .
    ceq findPath(NS, ND, G) = (if P? :: NePath{E} then P? else noPath fi)
        if P? := findNePath(NS, ND, G) [owise] .

    op findNePath : E$Node E$Node NeGraph{E} -> NePath?{E} .
    ceq findNePath(NS, ND, E || G) = E
        if NS ND := nodes(E) /\ from(E, NS) /\ to(E, ND) .
    ceq findNePath(NS, ND, E || G) = E P
        if NS N := nodes(E) /\ from(E, NS) /\ to(E, N)
        /\ P := findPath(N, ND, G) .
    ceq findNePath(NS, ND, E || G) = E P
        if N ND := nodes(E) /\ from(E, N) /\ to(E, ND)
        /\ P := findPath(NS, N, G) .
    eq findNePath(NS, ND, G) = noNePath [owise] .
endfm

fmod QID-GRAPH-PATH is
    protecting GRAPH-PATH{QidEdge} * (sort Graph{QidEdge} to QidGraph,
                                      sort NeGraph{QidEdge} to NeQidGraph,
                                      sort NodeSet{QidEdge} to QidSet,
                                      sort NeNodeSet{QidEdge} to NeQidSet,
                                      sort Path{QidEdge} to QidPath,
                                      sort NePath{QidEdge} to NeQidPath,
                                      sort Path?{QidEdge} to QidPath?,
                                      sort NePath?{QidEdge} to NeQidPath?) .
endfm

